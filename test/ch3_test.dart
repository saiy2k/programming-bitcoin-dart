import 'package:crypto/crypto.dart';
import 'dart:convert';
import 'dart:typed_data';

import 'package:dart_bitcoin/ecc/field_element.dart';
import 'package:dart_bitcoin/ecc/point.dart';
import 'package:dart_bitcoin/ecc/private_key.dart';
import 'package:dart_bitcoin/ecc/s_256_field.dart';
import 'package:dart_bitcoin/ecc/s_256_point.dart';
import 'package:dart_bitcoin/ecc/signature.dart';
import 'package:pointycastle/pointycastle.dart' hide Signature, Digest, PrivateKey;
import 'package:test/test.dart';

import 'const_nos.dart';

void main() {
  BigInt prime = BigInt.from(223);
  group('Ch3: Elliptic curve cryptography (ECC)', () {
    test('Ex1: Points on curve y^2 = x^3 + 7 over F233; (192, 105), (17, 56), (200, 119), (1, 193), (42, 99)', () {
      // (192, 105)
      FieldElement fe192 = FieldElement(i192, i223);
      FieldElement fe105 = FieldElement(i105, i223);
      Point p1 = Point(fe192, fe105, feA, feB);
      expect(p1, isNotNull);

      // (17, 56)
      FieldElement fe17 = FieldElement(i17, i223);
      FieldElement fe56 = FieldElement(i56, i223);
      Point p2 = Point(fe17, fe56, feA, feB);
      expect(p2, isNotNull);

      // (200, 119)
      FieldElement fe200 = FieldElement(i200, i223);
      FieldElement fe119 = FieldElement(i119, i223);
      expect(() => Point(fe200, fe119, feA, feB), throwsArgumentError);

      // (1, 193)
      FieldElement fe1 = FieldElement(i1, i223);
      FieldElement fe193 = FieldElement(i193, i223);
      Point p4 = Point(fe1, fe193, feA, feB);
      expect(p4, isNotNull);

      // (42, 99)
      FieldElement fe42 = FieldElement(i42, i223);
      FieldElement fe99 = FieldElement(i99, i223);
      expect(() => Point(fe42, fe99, feA, feB), throwsArgumentError);
    });
    test('Ex2: (170, 142) + (60, 139); (47, 71) + (17, 56); (143, 98) + (76, 66) over F233', () {
      // (170, 142) + (60, 139)
      FieldElement fe170 = FieldElement(i170, i223);
      FieldElement fe142 = FieldElement(i142, i223);
      FieldElement fe60 = FieldElement(i60, i223);
      FieldElement fe139 = FieldElement(i139, i223);

      Point p1 = Point(fe170, fe142, feA, feB);
      Point p2 = Point(fe60, fe139, feA, feB);

      Point pSum1 = p1 + p2;

      expect(pSum1.x?.num, equals(i220));
      expect(pSum1.y?.num, equals(i181));

      // (47, 71) + (17, 56)
      FieldElement fe47 = FieldElement(i47, i223);
      FieldElement fe71 = FieldElement(i71, i223);
      FieldElement fe17 = FieldElement(i17, i223);
      FieldElement fe56 = FieldElement(i56, i223);

      Point p3 = Point(fe47, fe71, feA, feB);
      Point p4 = Point(fe17, fe56, feA, feB);

      Point pSum2 = p3 + p4;

      expect(pSum2.x?.num, equals(i215));
      expect(pSum2.y?.num, equals(i68));

      // (143, 98) + (76, 66)
      FieldElement fe143 = FieldElement(i143, i223);
      FieldElement fe98 = FieldElement(i98, i223);
      FieldElement fe76 = FieldElement(i76, i223);
      FieldElement fe66 = FieldElement(i66, i223);

      Point p5 = Point(fe143, fe98, feA, feB);
      Point p6 = Point(fe76, fe66, feA, feB);

      Point pSum3 = p5 + p6;

      expect(pSum3.x?.num, equals(i47));
      expect(pSum3.y?.num, equals(i71));
    });
    test('Ex4: 2 * (192, 105); 2 * (143, 98); 2 * (47, 71); 4 * (47, 71); 8 * (47, 71); 21 * (47, 71); over F233', () {
      // 2 * (192, 105)
      FieldElement fe192 = FieldElement(i192, i223);
      FieldElement fe105 = FieldElement(i105, i223);

      Point p1 = Point(fe192, fe105, feA, feB);
      Point prod = p1.smult(BigInt.two);

      expect(prod.x?.num, equals(i49));
      expect(prod.y?.num, equals(i71));

      // 2 * (143, 98)
      FieldElement fe143 = FieldElement(i143, i223);
      FieldElement fe98 = FieldElement(i98, i223);

      Point p2 = Point(fe143, fe98, feA, feB);
      Point prod2 = p2.smult(BigInt.two);

      expect(prod2.x?.num, equals(i64));
      expect(prod2.y?.num, equals(i168));

      // 2 * (47, 71)
      FieldElement fe47 = FieldElement(i47, i223);
      FieldElement fe71 = FieldElement(i71, i223);

      Point p3 = Point(fe47, fe71, feA, feB);
      Point prod3 = p3.smult(BigInt.two);

      expect(prod3.x?.num, equals(i36));
      expect(prod3.y?.num, equals(i111));

      // 4 * (47, 71)
      Point prod4 = p3.smult(i4);

      expect(prod4.x?.num, equals(i194));
      expect(prod4.y?.num, equals(i51));

      // 8 * (47, 71)
      Point prod5 = p3.smult(i8);

      expect(prod5.x?.num, equals(i116));
      expect(prod5.y?.num, equals(i55));

      // 21 * (47, 71)
      Point prod6 = p3.smult(i21);

      expect(prod6.x?.num, isNull);
      expect(prod6.y?.num, isNull);
    });

    test('Ex4: secp256k1: n*G = Infinity ', () {
      BigInt n = S256Point.n;
      S256Point G = S256Point.G;
      Point p = G.smult(n);

      expect(p.x?.num, isNull);
      expect(p.y?.num, isNull);
    });

    test('Ex5: Order of the group generated by (15, 86)', () {
      FieldElement fe15 = FieldElement(i15, i223);
      FieldElement fe86 = FieldElement(i86, i223);

      Point p1 = Point(fe15, fe86, feA, feB);
      Point res = p1;

      int i = 1;
      while (res.x != null) {
        res = res + p1;
        print(res);
        i++;
      }

      expect(i, equals(7));
    });

    test('Ex6: Signature validity', () {
      BigInt x = BigInt.parse('887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c', radix: 16);
      BigInt y = BigInt.parse('61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34', radix: 16);
      S256Point P = S256Point(x, y);

      BigInt z1 = BigInt.parse('ec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60', radix: 16);
      BigInt r1 = BigInt.parse('ac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395', radix: 16);
      BigInt s1 = BigInt.parse('68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4', radix: 16);
      Signature sig1 = Signature(r1, s1);

      bool valid1 = P.verify(z1, sig1);
      expect(valid1, isTrue);

      BigInt z2 = BigInt.parse('7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d', radix: 16);
      BigInt r2 = BigInt.parse('eff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c', radix: 16);
      BigInt s2 = BigInt.parse('c7207fee197d27c618aea621406f6bf5ef6fca38681d82b2f06fddbdce6feab6', radix: 16);
      Signature sig2 = Signature(r2, s2);

      bool valid2 = P.verify(z2, sig2);
      expect(valid2, isTrue);
    });

    // TODO: Not right
    test('Ex7: Sign a message', () {
      BigInt secret = BigInt.from(12345);
      Uint8List bytes = utf8.encode('Programming Bitcoin!');
      Digest digest = sha256.convert(bytes);
      BigInt z = BigInt.parse(digest.toString(), radix: 16);

      PrivateKey pk = PrivateKey(secret);
      print(pk.point);

      Signature sig = pk.sign(z);

      print(sig);

      print('Digest as bytes: ${digest.bytes}');
      print('Digest as bytes: ${digest.toString()}');
    });
  });
}
